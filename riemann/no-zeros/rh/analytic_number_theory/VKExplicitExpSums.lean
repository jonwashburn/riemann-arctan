/-
Copyright (c) 2025 Jonathan Washburn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.

Explicit Vinogradov–Korobov (VK) exponential–sum bounds
=======================================================

Purpose
-------
This standalone module wires a precise API for the exponential–sum bounds
used in the Vinogradov–Korobov zero–density method (and Ford–Khale style
sharpenings). It provides:
  - a record for exponent pairs;
  - a recursive definition of valid exponent pairs (Process A, Process B);
  - a Dirichlet–polynomial model for approximants to ζ′/ζ on vertical lines;
  - an abstract, constant–explicit exponential–sum bound in the uniform
    (x, t)-range needed by Khale/Ford, parameterized by an exponent pair.

Status
------
This file now defines `ExponentPair` constructively. The core bound `expSum_bound_uniform`
is derived from the `ValidExponentPair` structure, contingent on atomic lemmas
(axiomatized in `VKBounds`) for Processes A/B and the base case.
-/

import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Data.Complex.Basic
import Mathlib.MeasureTheory.Integral.SetIntegral
import Mathlib.Algebra.BigOperators.Group.Finset
import Mathlib.Tactic

open ComplexConjugate

namespace RH.ANT.VinogradovKorobov

noncomputable section

open scoped BigOperators

/-- An exponent pair (κ, λ) in the sense of exponent–pair theory.
We record 0 ≤ κ ≤ 1/2 and 1/2 ≤ λ ≤ 1, which cover all standard pairs. -/
structure ExponentPair where
  kappa : ℝ
  lambda : ℝ
  hk_lo : 0 ≤ kappa
  hk_hi : kappa ≤ (1 : ℝ) / 2
  hl_lo : (1 : ℝ) / 2 ≤ lambda
  hl_hi : lambda ≤ 1
  hsum : kappa + lambda ≤ 1

/-- Inductive definition of valid exponent pairs generated by Processes A and B. -/
inductive ValidExponentPair : ExponentPair → Prop where
  /-- The trivial pair (0, 1) is valid. -/
  | trivial : ValidExponentPair {
      kappa := 0,
      lambda := 1,
      hk_lo := le_rfl,
      hk_hi := by norm_num,
      hl_lo := by norm_num,
      hl_hi := le_rfl,
      hsum := by norm_num
    }
  /-- Process A: (κ, λ) -> (κ/(2κ+2), (κ+λ+1)/(2κ+2)) -/
  | processA {ep : ExponentPair} (h : ValidExponentPair ep) :
      ValidExponentPair {
        kappa := ep.kappa / (2 * ep.kappa + 2),
        lambda := (ep.kappa + ep.lambda + 1) / (2 * ep.kappa + 2),
        hk_lo := by
          have : 0 ≤ 2 * ep.kappa + 2 := add_nonneg (mul_nonneg (by norm_num) ep.hk_lo) (by norm_num)
          exact div_nonneg ep.hk_lo this,
        hk_hi := by
          have h1 : ep.kappa ≤ 1/2 := ep.hk_hi
          have h2 : 0 ≤ ep.kappa := ep.hk_lo
          have pos_denom : 0 < 2 * ep.kappa + 2 := by linarith
          rw [div_le_iff₀ pos_denom]
          linarith,
        hl_lo := by
          have h1 : 1/2 ≤ ep.lambda := ep.hl_lo
          have h2 : 0 ≤ ep.kappa := ep.hk_lo
          have pos_denom : 0 < 2 * ep.kappa + 2 := by linarith
          rw [le_div_iff₀ pos_denom]
          linarith,
        hl_hi := by
          have h1 : ep.lambda ≤ 1 := ep.hl_hi
          have h2 : 0 ≤ ep.kappa := ep.hk_lo
          have pos_denom : 0 < 2 * ep.kappa + 2 := by linarith
          rw [div_le_iff₀ pos_denom]
          linarith,
        hsum := by
          have h1 : ep.kappa + ep.lambda ≤ 1 := ep.hsum
          have h2 : 0 ≤ ep.kappa := ep.hk_lo
          have pos_denom : 0 < 2 * ep.kappa + 2 := by linarith
          rw [← add_div, div_le_iff₀ pos_denom]
          linarith
      }
  /-- Process B: (κ, λ) -> (λ - 1/2, κ + 1/2) -/
  | processB {ep : ExponentPair} (h : ValidExponentPair ep) :
      ValidExponentPair {
        kappa := ep.lambda - 1/2,
        lambda := ep.kappa + 1/2,
        hk_lo := sub_nonneg.mpr ep.hl_lo,
        hk_hi := by
          have : ep.lambda ≤ 1 := ep.hl_hi; linarith,
        hl_lo := by
          have : 0 ≤ ep.kappa := ep.hk_lo
          linarith,
        hl_hi := by
           have : ep.kappa ≤ 1/2 := ep.hk_hi
           linarith,
        hsum := by
          have : ep.kappa + ep.lambda ≤ 1 := ep.hsum; linarith
      }

namespace ExponentPair

/-- A commonly used baseline exponent pair (0,1). -/
def trivial : ExponentPair where
  kappa := 0
  lambda := 1
  hk_lo := le_rfl
  hk_hi := by norm_num
  hl_lo := by norm_num
  hl_hi := le_rfl
  hsum := by norm_num

theorem trivial_isValid : ValidExponentPair trivial := ValidExponentPair.trivial

end ExponentPair

/-- A simple Dirichlet–polynomial model for ζ′/ζ approximants.  The coefficient function
vanishes implicitly outside the initial segment `Icc 1 (Nat.ceil X)`. -/
structure DirichletPoly where
  coeff : ℕ → ℂ
  /-- Truncation height (e.g., X) controlling the support. -/
  X : ℝ
  hX : 1 ≤ X
  /-- Coefficients are bounded by 1 (normalization). -/
  norm_coeff_le_one : ∀ n, ‖coeff n‖ ≤ 1

namespace DirichletPoly

/-- Natural truncation level used for finite sums. -/
def trunc (P : DirichletPoly) : ℕ :=
  Nat.ceil P.X

lemma trunc_pos (P : DirichletPoly) : 1 ≤ P.trunc := by
  have := Nat.ceil_mono (show (1 : ℝ) ≤ P.X from P.hX)
  simpa [trunc]

/-- The finite index set describing the truncated Dirichlet polynomial. -/
def evalSupport (P : DirichletPoly) : Finset ℕ :=
  Finset.Icc 1 P.trunc

lemma mem_evalSupport {P : DirichletPoly} {n : ℕ} :
    n ∈ P.evalSupport ↔ 1 ≤ n ∧ n ≤ P.trunc := by
  simpa [evalSupport] using Finset.mem_Icc

/-- Cardinality of the evaluation support. -/
lemma card_evalSupport (P : DirichletPoly) :
    P.evalSupport.card = P.trunc := by
  simpa [evalSupport] using
    (Finset.card_Icc (α := ℕ) (m := 1) (n := P.trunc))

/-- The Dirichlet term at index `n`; vanishes outside the contiguous support. -/
noncomputable def term (P : DirichletPoly) (σ t : ℝ) (n : ℕ) : ℂ :=
  if h : 1 ≤ n ∧ n ≤ P.trunc then
    P.coeff n * (n : ℂ) ^ (-(σ + Complex.I * t))
  else
    0

/-- Explicit formula for `term` inside the support. -/
lemma term_of_mem {P : DirichletPoly} {σ t : ℝ} {n : ℕ}
    (h₁ : 1 ≤ n) (h₂ : n ≤ P.trunc) :
    P.term σ t n = P.coeff n * (n : ℂ) ^ (-(σ + Complex.I * t)) := by
  have h : 1 ≤ n ∧ n ≤ P.trunc := ⟨h₁, h₂⟩
  simp [term, h]

/-- Outside the truncated support the Dirichlet term is zero. -/
@[simp] lemma term_of_not_mem {P : DirichletPoly} {σ t : ℝ} {n : ℕ}
    (h : ¬ (1 ≤ n ∧ n ≤ P.trunc)) :
    P.term σ t n = 0 := by
  classical
  simp [term, h]

/-- Evaluate a Dirichlet polynomial on `s = σ + it` using the contiguous support. -/
noncomputable def evalAt (P : DirichletPoly) (σ t : ℝ) : ℂ :=
  P.evalSupport.sum (fun n => P.coeff n * (n : ℂ) ^ (-(σ + Complex.I * t)))

/-- Expression of `evalAt` via the total `term` function. -/
lemma evalAt_eq_sum_term (P : DirichletPoly) (σ t : ℝ) :
    P.evalAt σ t = ∑ n in P.evalSupport, P.term σ t n := by
  classical
  unfold evalAt
  refine Finset.sum_congr rfl ?_
  intro n hn
  have h : 1 ≤ n ∧ n ≤ P.trunc := by
    simpa [evalSupport, Finset.mem_Icc] using hn
  simp [evalAt, term, evalSupport, Finset.mem_Icc, hn, h]

/-- Variant summing along the contiguous `Icc`. -/
lemma evalAt_eq_sum_Icc (P : DirichletPoly) (σ t : ℝ) :
    P.evalAt σ t = ∑ n in Finset.Icc 1 P.trunc, P.term σ t n := by
  simpa [evalSupport] using P.evalAt_eq_sum_term σ t

end DirichletPoly

/-
Uniform exponential–sum bound
-----------------------------
We encode the uniform bound needed by Khale/Ford in the VK method.
The bounds are now derived from the `ValidExponentPair` structure.
-/

/-- Parameters and envelope for the VK uniform bound. -/
structure VKBounds where
  /-- absolute constant in the bound -/
  C0 : ℝ
  /-- power of log factor -/
  Clog : ℝ
  /-- exponent–pair dependent saving factor -/
  Cpair : ℝ
  /-- admissible σ-window; typical VK proofs take σ≈1 in mollified transforms -/
  sigma : ℝ
  hC0 : 0 ≤ C0
  hClog : 0 ≤ Clog
  hCpair : 0 ≤ Cpair
  hσ : 0 ≤ sigma ∧ sigma ≤ 2
  /-- The constants must be sufficient to cover the trivial bound (sum of norms). -/
  h_triv : ∀ (x : ℝ), 2 ≤ x →
    (∑ n in Finset.Icc 1 (Nat.ceil x), (n : ℝ) ^ (-sigma))
      ≤ C0 * Real.rpow x (1 - sigma) * (Real.log (max x (Real.exp 1))) ^ Clog
  /-- Process A preservation axiom: if a bound holds, Process A preserves it (Weyl). -/
  h_processA : ∀ (ep : ExponentPair) (K : ℝ → ℝ → ℝ),
    (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → 1 ≤ |t| → ‖P.evalAt sigma t‖ ≤ K x t * Real.rpow x (ep.lambda - sigma) * Real.rpow (1 + |t|/x) ep.kappa) →
    (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → 1 ≤ |t| → ‖P.evalAt sigma t‖ ≤ K x t * Real.rpow x (((ep.kappa+ep.lambda+1)/(2*ep.kappa+2)) - sigma) * Real.rpow (1 + |t|/x) (ep.kappa/(2*ep.kappa+2)))
  /-- Process B preservation axiom: if a bound holds, Process B preserves it (Van der Corput). -/
  h_processB : ∀ (ep : ExponentPair) (K : ℝ → ℝ → ℝ),
    (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → 1 ≤ |t| →
        ‖P.evalAt sigma t‖ ≤ K x t * Real.rpow x (ep.lambda - sigma) *
          Real.rpow (1 + |t| / x) ep.kappa) →
    (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → 1 ≤ |t| →
        ‖P.evalAt sigma t‖ ≤ K x t * Real.rpow x ((ep.kappa + 1 / 2) - sigma) *
          Real.rpow (1 + |t| / x) (ep.lambda - 1 / 2))
  /-- Monotonicity of the pair-dependent constant under Process A. -/
  h_monotone_A : ∀ (ep : ExponentPair),
    1 + Cpair * (2 - (ep.kappa + ep.lambda)) ≤ 1 + Cpair * (2 - ((ep.kappa+ep.lambda+1)/(2*ep.kappa+2)))
  /-- Monotonicity of the pair-dependent constant under Process B. -/
  h_monotone_B : ∀ (ep : ExponentPair),
    1 + Cpair * (2 - (ep.kappa + ep.lambda)) ≤ 1 + Cpair * (2 - ((ep.lambda-1/2) + (ep.kappa+1/2)))

/-- Atomic Axiom: The van der Corput bound for the trivial pair (0,1).
    This corresponds to the trivial bound on the sum. -/
theorem atomic_bound_trivial (bounds : VKBounds) (t0 : ℝ) (ht0 : 1 ≤ t0) :
  ∀ (P : DirichletPoly) {x t : ℝ},
    2 ≤ x → P.X ≤ x → t0 ≤ |t| →
    ‖P.evalAt bounds.sigma t‖ ≤ bounds.C0 * Real.rpow x (1 - bounds.sigma) * (Real.log (max x (Real.exp 1))) ^ bounds.Clog := by
  intro P x t hx hP ht
  have h_sum := bounds.h_triv x hx
  rw [P.evalAt_eq_sum_Icc]
  let S := ∑ n in Finset.Icc 1 P.trunc, ‖P.term bounds.sigma t n‖
  have h_norm : ‖∑ n in Finset.Icc 1 P.trunc, P.term bounds.sigma t n‖ ≤ S :=
    norm_sum_le _ _
  have h_term :
      ∀ n ∈ Finset.Icc 1 P.trunc, ‖P.term bounds.sigma t n‖ ≤ (n : ℝ) ^ (-bounds.sigma) := by
    intro n hn
    have h_mem : 1 ≤ n ∧ n ≤ P.trunc := by simpa using hn
    rcases h_mem.1 with hpos
    have hn_pos_nat : 0 < n := Nat.succ_le_iff.mp hpos
    have hn_pos : 0 < (n : ℝ) := by exact_mod_cast hn_pos_nat
    have h_abs :
        Complex.abs ((n : ℂ) ^ (-(bounds.sigma + Complex.I * t)))
          = (n : ℝ) ^ (-bounds.sigma) := by
      have := Complex.abs_cpow_eq_rpow_re_of_pos hn_pos (-(bounds.sigma + Complex.I * t))
      simpa [Complex.add_re, Complex.mul_re, Complex.I_re, Complex.I_im,
        add_comm, add_left_comm, add_assoc, sub_eq_add_neg] using this
    have h_coeff : ‖P.coeff n‖ ≤ 1 := P.norm_coeff_le_one n
    have hpow_nonneg : 0 ≤ (n : ℝ) ^ (-bounds.sigma) :=
      Real.rpow_nonneg (Nat.cast_nonneg n) (-bounds.sigma)
    have h_term_eq :
        ‖P.term bounds.sigma t n‖ =
          ‖P.coeff n‖ * (n : ℝ) ^ (-bounds.sigma) := by
      simp [DirichletPoly.term, h_mem, norm_mul, Complex.norm_eq_abs, h_abs]
    have h_le :
        ‖P.coeff n‖ * (n : ℝ) ^ (-bounds.sigma)
          ≤ (n : ℝ) ^ (-bounds.sigma) :=
      mul_le_of_le_one_left hpow_nonneg h_coeff
    simpa [h_term_eq] using h_le
  have h_S_le : S ≤ ∑ n in Finset.Icc 1 P.trunc, (n : ℝ) ^ (-bounds.sigma) := by
    apply Finset.sum_le_sum h_term
  have h_subset : Finset.Icc 1 P.trunc ⊆ Finset.Icc 1 (Nat.ceil x) := by
    intro y hy
    rw [Finset.mem_Icc] at hy ⊢
    refine ⟨hy.1, ?_⟩
    have h_trunc_le : P.trunc ≤ Nat.ceil x := Nat.ceil_mono hP
    exact le_trans hy.2 h_trunc_le
  have h_sum_extend :
      (∑ n in Finset.Icc 1 P.trunc, (n : ℝ) ^ (-bounds.sigma))
      ≤ (∑ n in Finset.Icc 1 (Nat.ceil x), (n : ℝ) ^ (-bounds.sigma)) := by
    apply Finset.sum_le_sum_of_subset_of_nonneg h_subset
    intro n _ _
    apply Real.rpow_nonneg (Nat.cast_nonneg n)
  apply le_trans h_norm
  apply le_trans h_S_le
  apply le_trans h_sum_extend
  exact h_sum

/-- Atomic Axiom: Process A preserves the bound structure (Weyl differencing). -/
theorem atomic_process_A (ep : ExponentPair) (bounds : VKBounds) (t0 : ℝ) (ht0_eq_1 : t0 = 1) (K : ℝ → ℝ → ℝ) :
  (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → t0 ≤ |t| → ‖P.evalAt bounds.sigma t‖ ≤ K x t * Real.rpow x (ep.lambda - bounds.sigma) * Real.rpow (1 + |t|/x) ep.kappa) →
  (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → t0 ≤ |t| → ‖P.evalAt bounds.sigma t‖ ≤ K x t * Real.rpow x (((ep.kappa+ep.lambda+1)/(2*ep.kappa+2)) - bounds.sigma) * Real.rpow (1 + |t|/x) (ep.kappa/(2*ep.kappa+2))) := by
  intro ih
  subst ht0_eq_1
  apply bounds.h_processA ep K
  intro P x t hx hP ht
  apply ih P x t hx hP ht

/-- Atomic Axiom: Process B preserves the bound structure (Van der Corput). -/
theorem atomic_process_B (ep : ExponentPair) (bounds : VKBounds) (t0 : ℝ) (ht0_eq_1 : t0 = 1) (K : ℝ → ℝ → ℝ) :
  (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → t0 ≤ |t| → ‖P.evalAt bounds.sigma t‖ ≤ K x t * Real.rpow x (ep.lambda - bounds.sigma) * Real.rpow (1 + |t|/x) ep.kappa) →
  (∀ (P : DirichletPoly) x t, 2 ≤ x → P.X ≤ x → t0 ≤ |t| → ‖P.evalAt bounds.sigma t‖ ≤ K x t * Real.rpow x ((ep.kappa+1/2) - bounds.sigma) * Real.rpow (1 + |t|/x) (ep.lambda-1/2)) := by
  intro ih
  subst ht0_eq_1
  apply bounds.h_processB ep K
  intro P x t hx hP ht
  apply ih P x t hx hP ht

/-- Explicit VK exponential–sum bound (Khale/Ford uniform range). -/
theorem expSum_bound_uniform
  (ep : ExponentPair)
  (h_valid : ValidExponentPair ep)
  (bounds : VKBounds)
  (t0 : ℝ) (ht0 : 1 ≤ t0)
  (ht0_eq_1 : t0 = 1)
  : ∀ (P : DirichletPoly),
    ∀ ⦃x t : ℝ⦄,
      2 ≤ x →
      P.X ≤ x →
      t0 ≤ |t| →
      ‖P.evalAt bounds.sigma t‖ ≤
        bounds.C0
          * Real.rpow x (ep.lambda - bounds.sigma)
          * Real.rpow (1 + |t| / x) ep.kappa
          * Real.rpow (Real.log (max x (Real.exp 1))) bounds.Clog
          * (1 + bounds.Cpair * (2 - (ep.kappa + ep.lambda))) := by
  induction h_valid
  case trivial =>
    intro P x t hx hP ht
    have h_atomic := atomic_bound_trivial bounds t0 ht0 P hx hP ht
    apply le_trans h_atomic
    simp only [ExponentPair.trivial]
    rw [Real.rpow_zero, mul_one]

    apply le_mul_of_one_le_right
    · apply mul_nonneg
      · apply mul_nonneg bounds.hC0
        apply Real.rpow_nonneg (le_trans (by norm_num) hx)
      · apply Real.rpow_nonneg
        apply Real.log_nonneg
        apply le_trans (by norm_num : (1:ℝ) ≤ 2)
        apply le_trans hx
        apply le_max_left
    · have : 0 ≤ bounds.Cpair := bounds.hCpair
      have : 0 ≤ 2 - (0 + 1 : ℝ) := by norm_num
      nlinarith

  case processA ep_prev h_prev ih =>
    intro P x t hx hP ht
    let K_val := 1 + bounds.Cpair * (2 - (ep_prev.kappa + ep_prev.lambda))
    let K_log := fun x => bounds.C0 * Real.rpow (Real.log (max x (Real.exp 1))) bounds.Clog
    let K : ℝ → ℝ → ℝ := fun x _ => K_log x * K_val
    have h_preservation :=
      atomic_process_A ep_prev bounds t0 ht0_eq_1 K
        (fun P' x' t' hx' hP' ht' => by
          specialize ih P' hx' hP' ht'
          simpa [K, K_log, K_val, mul_comm, mul_left_comm, mul_assoc])
    have := h_preservation P x t hx hP ht
    dsimp [K] at this
    simpa [K_log, K_val, mul_comm, mul_left_comm, mul_assoc]
      using this

  case processB ep_prev h_prev ih =>
    intro P x t hx hP ht
    let K_val := 1 + bounds.Cpair * (2 - (ep_prev.kappa + ep_prev.lambda))
    let K_log := fun x => bounds.C0 * Real.rpow (Real.log (max x (Real.exp 1))) bounds.Clog
    let K : ℝ → ℝ → ℝ := fun x _ => K_log x * K_val
    have h_preservation :=
      atomic_process_B ep_prev bounds t0 ht0_eq_1 K
        (fun P' x' t' hx' hP' ht' => by
          specialize ih P' hx' hP' ht'
          simpa [K, K_log, K_val, mul_comm, mul_left_comm, mul_assoc])
    have := h_preservation P x t hx hP ht
    dsimp [K] at this
    simpa [K_log, K_val, mul_comm, mul_left_comm, mul_assoc]
      using this

/-- Convenience theorem exposing the bound with the commonly used trivial exponent pair. -/
theorem expSum_bound_uniform_trivial
  (bounds : VKBounds) (t0 : ℝ) (ht0 : 1 ≤ t0) (ht0_eq_1 : t0 = 1)
  (P : DirichletPoly) {x t : ℝ}
  (hx : 2 ≤ x) (hPX : P.X ≤ x) (ht : t0 ≤ |t|)
  : ‖P.evalAt bounds.sigma t‖ ≤
      bounds.C0
        * Real.rpow x ((ExponentPair.trivial.lambda) - bounds.sigma)
        * Real.rpow (1 + |t| / x) (ExponentPair.trivial.kappa)
        * Real.rpow (Real.log (max x (Real.exp 1))) bounds.Clog
        * (1 + bounds.Cpair * (2 - (ExponentPair.trivial.kappa + ExponentPair.trivial.lambda))) := by
  have h_valid := ExponentPair.trivial_isValid
  exact expSum_bound_uniform ExponentPair.trivial h_valid bounds t0 ht0 ht0_eq_1 P hx hPX ht

end

end RH.ANT.VinogradovKorobov
